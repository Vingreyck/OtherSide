import socket
import threading
import pickle
import struct
import cv2
import numpy as np
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from PIL import Image, ImageTk
import io
import time

class OptimizedRemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Enhanced Remote Control Client")
        self.root.geometry("1200x800")
        
        # Variáveis de conexão
        self.socket = None
        self.connected = False
        self.receive_thread = None
        self.heartbeat_thread = None
        
        # Variáveis de controle
        self.last_mouse_move = 0
        self.mouse_throttle = 0.05  # 50ms entre movimentos do mouse
        self.screen_buffer = None
        self.last_screen_update = 0
        
        # Configurações de interface
        self.create_interface()
    
    def create_interface(self):
        """Cria a interface gráfica do cliente."""
        # Frame principal
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Frame de conexão
        connection_frame = ttk.LabelFrame(main_frame, text="Conexão")
        connection_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Host:").grid(row=0, column=0, padx=5, pady=5)
        self.host_entry = ttk.Entry(connection_frame, width=20)
        self.host_entry.insert(0, "localhost")
        self.host_entry.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Porta:").grid(row=0, column=2, padx=5, pady=5)
        self.port_entry = ttk.Entry(connection_frame, width=8)
        self.port_entry.insert(0, "9999")
        self.port_entry.grid(row=0, column=3, padx=5, pady=5)
        
        self.connect_button = ttk.Button(connection_frame, text="Conectar", command=self.toggle_connection)
        self.connect_button.grid(row=0, column=4, padx=5, pady=5)
        
        # Frame de visualização
        view_frame = ttk.LabelFrame(main_frame, text="Tela Remota")
        view_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Canvas para exibir tela remota
        self.canvas = tk.Canvas(view_frame, bg="black")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Eventos de mouse e teclado
        self.canvas.bind("<Motion>", self.on_mouse_move)
        self.canvas.bind("<Button-1>", lambda e: self.send_mouse_click("left"))
        self.canvas.bind("<Button-3>", lambda e: self.send_mouse_click("right"))
        self.canvas.bind("<Key>", self.on_key_press)
        self.canvas.focus_set()
        
        # Frame de controles
        control_frame = ttk.LabelFrame(main_frame, text="Controles")
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Controle de qualidade
        ttk.Label(control_frame, text="Qualidade:").grid(row=0, column=0, padx=5, pady=5)
        self.quality_var = tk.StringVar(value="Normal")
        quality_combo = ttk.Combobox(control_frame, textvariable=self.quality_var, 
                                     values=["Baixa", "Normal", "Alta"], width=8, state="readonly")
        quality_combo.grid(row=0, column=1, padx=5, pady=5)
        quality_combo.bind("<<ComboboxSelected>>", self.change_quality)
        
        # Botões de controle
        control_buttons = [
            ("Informações do Sistema", self.get_system_info),
            ("Executar Comando", self.open_command_dialog)
        ]
        
        for i, (text, command) in enumerate(control_buttons):
            btn = ttk.Button(control_frame, text=text, command=command)
            btn.grid(row=0, column=i+2, padx=5, pady=5)
        
        # Console de log
        log_frame = ttk.LabelFrame(main_frame, text="Log")
        log_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.log_console = scrolledtext.ScrolledText(log_frame, height=10)
        self.log_console.pack(fill=tk.BOTH, expand=True)
        
        # Desabilita controles inicialmente
        self.set_control_state(False)
    
    def log(self, message):
        """Adiciona mensagem ao console de log."""
        self.log_console.config(state=tk.NORMAL)
        self.log_console.insert(tk.END, f"{time.strftime('%H:%M:%S')} - {message}\n")
        self.log_console.see(tk.END)
        self.log_console.config(state=tk.DISABLED)
    
    def toggle_connection(self):
        """Alterna entre conectar e desconectar."""
        if not self.connected:
            self.connect()
        else:
            self.disconnect()
    
    def connect(self):
        """Estabelece conexão com o servidor."""
        host = self.host_entry.get()
        port = int(self.port_entry.get())
        
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            
            # Aumenta os buffers de rede
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1048576)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1048576)
            
            # Define timeout para a conexão inicial
            self.socket.settimeout(10.0)
            
            self.log(f"Conectando a {host}:{port}...")
            self.socket.connect((host, port))
            self.connected = True
            
            # Aguarda 100ms para garantir que a conexão esteja estabelecida
            time.sleep(0.1)
            
            # Envia o tamanho da tela para o servidor
            screen_width = self.canvas.winfo_width()
            screen_height = self.canvas.winfo_height()
            self.send_data((screen_width, screen_height))
            
            # Atualiza interface
            self.connect_button.config(text="Desconectar")
            self.set_control_state(True)
            self.log(f"Conectado a {host}:{port}")
            
            # Inicia thread de recebimento
            self.receive_thread = threading.Thread(target=self.receive_data)
            self.receive_thread.daemon = True
            self.receive_thread.start()
            
            # Inicia thread de heartbeat
            self.heartbeat_thread = threading.Thread(target=self.heartbeat)
            self.heartbeat_thread.daemon = True
            self.heartbeat_thread.start()
            
        except Exception as e:
            self.log(f"Erro de conexão: {e}")
            messagebox.showerror("Erro", str(e))
            if self.socket:
                self.socket.close()
                self.socket = None
    
    def heartbeat(self):
        """Envia sinal de heartbeat periódico para manter a conexão ativa."""
        while self.connected:
            try:
                time.sleep(5)  # Envia a cada 5 segundos
                if self.connected:
                    self.send_data("heartbeat")
            except:
                # Se falhar, a thread de recebimento detectará e desconectará
                pass
    
    def disconnect(self):
        """Encerra conexão com o servidor."""
        self.connected = False
        
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            
            self.socket = None
            
        # Reseta interface
        self.connect_button.config(text="Conectar")
        self.set_control_state(False)
        self.canvas.delete("all")
        self.log("Desconectado")
    
    def set_control_state(self, enabled):
        """Habilita/desabilita controles."""
        state = tk.NORMAL if enabled else tk.DISABLED
        # Adicione aqui outros controles que devem ser habilitados/desabilitados
    
    def send_data(self, data):
        """Envia dados serializados para o servidor."""
        if not self.connected or not self.socket:
            return False
        
        try:
            serialized = pickle.dumps(data)
            
            # Envia o tamanho dos dados primeiro
            header = struct.pack("Q", len(serialized))
            self.socket.sendall(header)
            
            # Envia os dados em chunks para evitar problemas com pacotes grandes
            bytes_sent = 0
            while bytes_sent < len(serialized):
                chunk_size = min(32768, len(serialized) - bytes_sent)  # Envia 32KB por vez
                self.socket.sendall(serialized[bytes_sent:bytes_sent + chunk_size])
                bytes_sent += chunk_size
                
            return True
        except Exception as e:
            self.log(f"Erro ao enviar dados: {e}")
            self.disconnect()
            return False
    
    def receive_data(self):
        """Recebe dados do servidor continuamente."""
        buffer_incomplete = False
        incomplete_data = b""
        
        while self.connected:
            try:
                if not buffer_incomplete:
                    # Recebe tamanho dos dados
                    header = self.socket.recv(8)
                    if not header or len(header) < 8:
                        if len(header) > 0:
                            self.log(f"Cabeçalho incompleto: {len(header)} bytes")
                        raise ConnectionError("Cabeçalho incompleto ou conexão fechada")
                    
                    data_size = struct.unpack("Q", header)[0]
                    
                    # Verifica se o tamanho é razoável
                    if data_size > 100000000:  # Limite de 100MB
                        self.log(f"Tamanho de dados excessivo: {data_size}")
                        raise ConnectionError("Tamanho de dados inválido")
                    
                    # Recebe dados em chunks
                    data = b""
                    remaining = data_size
                else:
                    # Continua recebendo dados incompletos
                    data = incomplete_data
                    remaining = data_size - len(data)
                    buffer_incomplete = False
                
                # Define um timeout para cada operação de recebimento
                self.socket.settimeout(10.0)
                
                start_time = time.time()
                while remaining > 0:
                    # Verifica se já passou muito tempo (30 segundos)
                    if time.time() - start_time > 30:
                        self.log("Timeout de recebimento excedido")
                        raise socket.timeout("Timeout de recebimento excedido")
                    
                    try:
                        chunk_size = min(remaining, 32768)  # Recebe no máximo 32KB por vez
                        chunk = self.socket.recv(chunk_size)
                        
                        if not chunk:
                            raise ConnectionError("Conexão fechada durante recebimento")
                        
                        data += chunk
                        remaining -= len(chunk)
                    except socket.timeout:
                        # Verifica se recebemos dados parciais
                        if len(data) > 0:
                            # Salva os dados parciais e continua na próxima iteração
                            incomplete_data = data
                            buffer_incomplete = True
                            self.log(f"Recebimento parcial: {len(data)}/{data_size} bytes")
                            break
                        else:
                            raise
                
                # Se recebemos dados incompletos, continue para a próxima iteração
                if buffer_incomplete:
                    continue
                
                # Desserializa dados
                decoded_data = pickle.loads(data)
                
                # Processa dados recebidos
                if isinstance(decoded_data, (bytes, bytearray, np.ndarray)):
                    # É uma imagem - armazenar no buffer
                    self.screen_buffer = decoded_data
                    # Atualizar a tela a cada 50ms (20 FPS máximo)
                    current_time = time.time()
                    if current_time - self.last_screen_update >= 0.05:
                        self.root.after(0, self.display_screen, decoded_data)
                        self.last_screen_update = current_time
                elif isinstance(decoded_data, (dict, str)):
                    # É uma mensagem ou informação
                    if decoded_data != "heartbeat_ok":  # Ignora respostas de heartbeat
                        self.log(f"Mensagem do servidor: {decoded_data}")
                
            except socket.timeout:
                self.log("Timeout de conexão - tentando continuar...")
                # Continua tentando - o heartbeat deve reiniciar a comunicação
            except Exception as e:
                self.log(f"Erro no recebimento: {e}")
                self.disconnect()
                break
    
    def display_screen(self, image_buffer):
        """Exibe imagem recebida do servidor."""
        if not self.connected:
            return
            
        try:
            # Converte buffer para imagem
            nparr = np.frombuffer(image_buffer, np.uint8)
            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Converte para formato do Tkinter
            img = Image.fromarray(frame)
            imgtk = ImageTk.PhotoImage(image=img)
            
            # Exibe no canvas
            self.canvas.config(width=img.width, height=img.height)
            self.canvas.delete("all")
            self.canvas.create_image(0, 0, anchor=tk.NW, image=imgtk)
            self.canvas.image = imgtk  # Mantém referência
            
        except Exception as e:
            self.log(f"Erro ao exibir imagem: {e}")
    
    def on_mouse_move(self, event):
        """Envia evento de movimento do mouse com throttling."""
        if self.connected:
            current_time = time.time()
            # Limita envio de eventos de mouse a cada 50ms
            if current_time - self.last_mouse_move >= self.mouse_throttle:
                self.send_data(f"mouse_move {event.x} {event.y}")
                self.last_mouse_move = current_time
    
    def send_mouse_click(self, button):
        """Envia clique do mouse."""
        if self.connected:
            self.send_data(f"mouse_click {button}")
    
    def on_key_press(self, event):
        """Envia evento de teclado."""
        if self.connected:
            key = event.char
            if key:
                self.send_data(f"keyboard {key}")
    
    def get_system_info(self):
        """Solicita informações do sistema."""
        if self.connected:
            self.send_data("system_info")
    
    def change_quality(self, event):
        """Altera a qualidade da transmissão."""
        quality = self.quality_var.get()
        if self.connected:
            # Envia comando de qualidade para o servidor
            self.send_data(f"quality {quality}")
            self.log(f"Qualidade alterada para: {quality}")
    
    def open_command_dialog(self):
        """Abre diálogo para executar comando."""
        if not self.connected:
            return
        
        # Cria janela de diálogo
        dialog = tk.Toplevel(self.root)
        dialog.title("Executar Comando")
        dialog.geometry("400x150")
        
        ttk.Label(dialog, text="Digite o comando:").pack(pady=10)
        
        command_entry = ttk.Entry(dialog, width=50)
        command_entry.pack(pady=10)
        
        def execute_command():
            cmd = command_entry.get()
            if cmd:
                self.send_data(f"exec {cmd}")
                dialog.destroy()
        
        ttk.Button(dialog, text="Executar", command=execute_command).pack(pady=10)
    
    def on_closing(self):
        """Tratamento de fechamento da janela."""
        if self.connected:
            self.disconnect()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = OptimizedRemoteClient(root)
    
    # Configura evento para após o carregamento da janela
    root.update()
    root.deiconify()
    
    # Configura evento de fechamento
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    
    # Inicia o loop principal
    root.mainloop()

if __name__ == "__main__":
    main()