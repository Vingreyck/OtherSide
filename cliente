import socket
import threading
import pickle
import struct
import cv2
import numpy as np
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from PIL import Image, ImageTk
import io

class EnhancedRemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Enhanced Remote Control Client")
        self.root.geometry("1200x800")
        
        # Variáveis de conexão
        self.socket = None
        self.connected = False
        self.receive_thread = None
        
        # Configurações de interface
        self.create_interface()
    
    def create_interface(self):
        """Cria a interface gráfica do cliente."""
        # Frame principal
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Frame de conexão
        connection_frame = ttk.LabelFrame(main_frame, text="Conexão")
        connection_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Host:").grid(row=0, column=0, padx=5, pady=5)
        self.host_entry = ttk.Entry(connection_frame, width=20)
        self.host_entry.insert(0, "localhost")
        self.host_entry.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Porta:").grid(row=0, column=2, padx=5, pady=5)
        self.port_entry = ttk.Entry(connection_frame, width=8)
        self.port_entry.insert(0, "9999")
        self.port_entry.grid(row=0, column=3, padx=5, pady=5)
        
        self.connect_button = ttk.Button(connection_frame, text="Conectar", command=self.toggle_connection)
        self.connect_button.grid(row=0, column=4, padx=5, pady=5)
        
        # Frame de visualização
        view_frame = ttk.LabelFrame(main_frame, text="Tela Remota")
        view_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Canvas para exibir tela remota
        self.canvas = tk.Canvas(view_frame, bg="black")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Eventos de mouse e teclado
        self.canvas.bind("<Motion>", self.on_mouse_move)
        self.canvas.bind("<Button-1>", lambda e: self.send_mouse_click("left"))
        self.canvas.bind("<Button-3>", lambda e: self.send_mouse_click("right"))
        self.canvas.bind("<Key>", self.on_key_press)
        self.canvas.focus_set()
        
        # Frame de controles
        control_frame = ttk.LabelFrame(main_frame, text="Controles")
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Botões de controle
        control_buttons = [
            ("Informações do Sistema", self.get_system_info),
            ("Executar Comando", self.open_command_dialog)
        ]
        
        for i, (text, command) in enumerate(control_buttons):
            btn = ttk.Button(control_frame, text=text, command=command)
            btn.grid(row=0, column=i, padx=5, pady=5)
        
        # Console de log
        log_frame = ttk.LabelFrame(main_frame, text="Log")
        log_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.log_console = scrolledtext.ScrolledText(log_frame, height=10)
        self.log_console.pack(fill=tk.BOTH, expand=True)
        
        # Desabilita controles inicialmente
        self.set_control_state(False)
    
    def log(self, message):
        """Adiciona mensagem ao console de log."""
        self.log_console.config(state=tk.NORMAL)
        self.log_console.insert(tk.END, f"{message}\n")
        self.log_console.see(tk.END)
        self.log_console.config(state=tk.DISABLED)
    
    def toggle_connection(self):
        """Alterna entre conectar e desconectar."""
        if not self.connected:
            self.connect()
        else:
            self.disconnect()
    
    def connect(self):
        """Estabelece conexão com o servidor."""
        host = self.host_entry.get()
        port = int(self.port_entry.get())
        
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((host, port))
            self.connected = True
            
            # Atualiza interface
            self.connect_button.config(text="Desconectar")
            self.set_control_state(True)
            self.log(f"Conectado a {host}:{port}")
            
            # Inicia thread de recebimento
            self.receive_thread = threading.Thread(target=self.receive_data)
            self.receive_thread.daemon = True
            self.receive_thread.start()
            
        except Exception as e:
            self.log(f"Erro de conexão: {e}")
            messagebox.showerror("Erro", str(e))
    
    def disconnect(self):
        """Encerra conexão com o servidor."""
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            
            self.socket = None
            self.connected = False
            
            # Reseta interface
            self.connect_button.config(text="Conectar")
            self.set_control_state(False)
            self.canvas.delete("all")
            self.log("Desconectado")
    
    def set_control_state(self, enabled):
        """Habilita/desabilita controles."""
        state = tk.NORMAL if enabled else tk.DISABLED
        # Adicione aqui outros controles que devem ser habilitados/desabilitados
    
    def send_data(self, data):
        """Envia dados serializados para o servidor."""
        if not self.connected:
            return
        
        try:
            serialized = pickle.dumps(data)
            self.socket.send(struct.pack("Q", len(serialized)) + serialized)
        except Exception as e:
            self.log(f"Erro ao enviar dados: {e}")
            self.disconnect()
    
    def receive_data(self):
        """Recebe dados do servidor continuamente."""
        while self.connected:
            try:
                # Recebe tamanho dos dados
                data_size = struct.unpack("Q", self.socket.recv(8))[0]
                
                # Recebe dados
                data = b""
                while len(data) < data_size:
                    packet = self.socket.recv(data_size - len(data))
                    data += packet
                
                # Desserializa dados
                decoded_data = pickle.loads(data)
                
                # Processa dados recebidos
                if isinstance(decoded_data, np.ndarray):
                    # É uma imagem
                    self.display_screen(decoded_data)
                elif isinstance(decoded_data, (dict, str)):
                    # É uma mensagem ou informação
                    self.log(str(decoded_data))
                
            except Exception as e:
                self.log(f"Erro no recebimento: {e}")
                self.disconnect()
                break
    
    def display_screen(self, image_buffer):
        """Exibe imagem recebida do servidor."""
        try:
            # Converte buffer para imagem
            nparr = np.frombuffer(image_buffer, np.uint8)
            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Converte para formato do Tkinter
            img = Image.fromarray(frame)
            imgtk = ImageTk.PhotoImage(image=img)
            
            # Exibe no canvas
            self.canvas.delete("all")
            self.canvas.create_image(0, 0, anchor=tk.NW, image=imgtk)
            self.canvas.image = imgtk  # Mantém referência
            
        except Exception as e:
            self.log(f"Erro ao exibir imagem: {e}")
    
    def on_mouse_move(self, event):
        """Envia evento de movimento do mouse."""
        if self.connected:
            self.send_data(f"mouse_move {event.x} {event.y}")
    
    def send_mouse_click(self, button):
        """Envia clique do mouse."""
        if self.connected:
            self.send_data(f"mouse_click {button}")
    
    def on_key_press(self, event):
        """Envia evento de teclado."""
        if self.connected:
            key = event.char
            if key:
                self.send_data(f"keyboard {key}")
    
    def get_system_info(self):
        """Solicita informações do sistema."""
        if self.connected:
            self.send_data("system_info")
    
    def open_command_dialog(self):
        """Abre diálogo para executar comando."""
        if not self.connected:
            return
        
        # Cria janela de diálogo
        dialog = tk.Toplevel(self.root)
        dialog.title("Executar Comando")
        dialog.geometry("400x150")
        
        ttk.Label(dialog, text="Digite o comando:").pack(pady=10)
        
        command_entry = ttk.Entry(dialog, width=50)
        command_entry.pack(pady=10)
        
        def execute_command():
            cmd = command_entry.get()
            if cmd:
                self.send_data(f"exec {cmd}")
                dialog.destroy()
        
        ttk.Button(dialog, text="Executar", command=execute_command).pack(pady=10)
    
    def on_closing(self):
        """Tratamento de fechamento da janela."""
        if self.connected:
            self.disconnect()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = EnhancedRemoteClient(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()