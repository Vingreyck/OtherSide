import socket
import threading
import pickle
import struct
import cv2
import numpy as np
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from PIL import Image, ImageTk
import io
import time

class OptimizedRemoteClient:
    def __init__(self, root):
        self.root = root
        self.root.title("Enhanced Remote Control Client")
        self.root.geometry("1200x800")
        
        # Variáveis de conexão
        self.socket = None
        self.connected = False
        self.receive_thread = None
        
        # Variáveis de controle
        self.last_mouse_move = 0
        self.mouse_throttle = 0.05  # 50ms entre movimentos do mouse
        self.screen_buffer = None
        self.last_screen_update = 0
        
        # Configurações de interface
        self.create_interface()
    
    def create_interface(self):
        """Cria a interface gráfica do cliente."""
        # Frame principal
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Frame de conexão
        connection_frame = ttk.LabelFrame(main_frame, text="Conexão")
        connection_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Host:").grid(row=0, column=0, padx=5, pady=5)
        self.host_entry = ttk.Entry(connection_frame, width=20)
        self.host_entry.insert(0, "localhost")
        self.host_entry.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(connection_frame, text="Porta:").grid(row=0, column=2, padx=5, pady=5)
        self.port_entry = ttk.Entry(connection_frame, width=8)
        self.port_entry.insert(0, "9999")
        self.port_entry.grid(row=0, column=3, padx=5, pady=5)
        
        self.connect_button = ttk.Button(connection_frame, text="Conectar", command=self.toggle_connection)
        self.connect_button.grid(row=0, column=4, padx=5, pady=5)
        
        # Frame de visualização
        view_frame = ttk.LabelFrame(main_frame, text="Tela Remota")
        view_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Canvas para exibir tela remota
        self.canvas = tk.Canvas(view_frame, bg="black")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Eventos de mouse e teclado
        self.canvas.bind("<Motion>", self.on_mouse_move)
        self.canvas.bind("<Button-1>", lambda e: self.send_mouse_click("left"))
        self.canvas.bind("<Button-3>", lambda e: self.send_mouse_click("right"))
        self.canvas.bind("<Key>", self.on_key_press)
        self.canvas.focus_set()
        
        # Frame de controles
        control_frame = ttk.LabelFrame(main_frame, text="Controles")
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Controle de qualidade
        ttk.Label(control_frame, text="Qualidade:").grid(row=0, column=0, padx=5, pady=5)
        self.quality_var = tk.StringVar(value="Normal")
        quality_combo = ttk.Combobox(control_frame, textvariable=self.quality_var, 
                                     values=["Baixa", "Normal", "Alta"], width=8, state="readonly")
        quality_combo.grid(row=0, column=1, padx=5, pady=5)
        quality_combo.bind("<<ComboboxSelected>>", self.change_quality)
        
        # Botões de controle
        control_buttons = [
            ("Informações do Sistema", self.get_system_info),
            ("Executar Comando", self.open_command_dialog)
        ]
        
        for i, (text, command) in enumerate(control_buttons):
            btn = ttk.Button(control_frame, text=text, command=command)
            btn.grid(row=0, column=i+2, padx=5, pady=5)
        
        # Console de log
        log_frame = ttk.LabelFrame(main_frame, text="Log")
        log_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.log_console = scrolledtext.ScrolledText(log_frame, height=10)
        self.log_console.pack(fill=tk.BOTH, expand=True)
        
        # Desabilita controles inicialmente
        self.set_control_state(False)
    
    def log(self, message):
        """Adiciona mensagem ao console de log."""
        self.log_console.config(state=tk.NORMAL)
        self.log_console.insert(tk.END, f"{message}\n")
        self.log_console.see(tk.END)
        self.log_console.config(state=tk.DISABLED)
    
    def toggle_connection(self):
        """Alterna entre conectar e desconectar."""
        if not self.connected:
            self.connect()
        else:
            self.disconnect()
    
    def connect(self):
        """Estabelece conexão com o servidor."""
        host = self.host_entry.get()
        port = int(self.port_entry.get())
        
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            
            # Aumenta os buffers de rede
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1048576)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1048576)
            
            self.socket.connect((host, port))
            self.connected = True
            
            # Envia o tamanho da tela para o servidor
            screen_width = self.canvas.winfo_width()
            screen_height = self.canvas.winfo_height()
            self.send_data((screen_width, screen_height))
            
            # Atualiza interface
            self.connect_button.config(text="Desconectar")
            self.set_control_state(True)
            self.log(f"Conectado a {host}:{port}")
            
            # Inicia thread de recebimento
            self.receive_thread = threading.Thread(target=self.receive_data)
            self.receive_thread.daemon = True
            self.receive_thread.start()
            
        except Exception as e:
            self.log(f"Erro de conexão: {e}")
            messagebox.showerror("Erro", str(e))
    
    def disconnect(self):
        """Encerra conexão com o servidor."""
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            
            self.socket = None
            self.connected = False
            
            # Reseta interface
            self.connect_button.config(text="Conectar")
            self.set_control_state(False)
            self.canvas.delete("all")
            self.log("Desconectado")
    
    def set_control_state(self, enabled):
        """Habilita/desabilita controles."""
        state = tk.NORMAL if enabled else tk.DISABLED
        # Adicione aqui outros controles que devem ser habilitados/desabilitados
    
    def send_data(self, data):
        """Envia dados serializados para o servidor."""
        if not self.connected:
            return
        
        try:
            serialized = pickle.dumps(data)
            self.socket.send(struct.pack("Q", len(serialized)) + serialized)
        except Exception as e:
            self.log(f"Erro ao enviar dados: {e}")
            self.disconnect()
    
    def receive_data(self):
        """Recebe dados do servidor continuamente."""
        while self.connected:
            try:
                # Recebe tamanho dos dados
                data_size = struct.unpack("Q", self.socket.recv(8))[0]
                
                # Recebe dados
                data = b""
                while len(data) < data_size:
                    packet = self.socket.recv(min(data_size - len(data), 4096))
                    if not packet:
                        raise ConnectionError("Conexão fechada")
                    data += packet
                
                # Desserializa dados
                decoded_data = pickle.loads(data)
                
                # Processa dados recebidos
                if isinstance(decoded_data, (bytes, np.ndarray)):
                    # É uma imagem - armazenar no buffer
                    self.screen_buffer = decoded_data
                    # Atualizar a tela a cada 50ms (20 FPS máximo)
                    current_time = time.time()
                    if current_time - self.last_screen_update >= 0.05:
                        self.display_screen(decoded_data)
                        self.last_screen_update = current_time
                elif isinstance(decoded_data, (dict, str)):
                    # É uma mensagem ou informação
                    self.log(str(decoded_data))
                
            except Exception as e:
                self.log(f"Erro no recebimento: {e}")
                self.disconnect()
                break
    
    def display_screen(self, image_buffer):
        """Exibe imagem recebida do servidor."""
        try:
            # Converte buffer para imagem
            nparr = np.frombuffer(image_buffer, np.uint8)
            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Converte para formato do Tkinter
            img = Image.fromarray(frame)
            imgtk = ImageTk.PhotoImage(image=img)
            
            # Exibe no canvas
            self.canvas.config(width=img.width, height=img.height)
            self.canvas.delete("all")
            self.canvas.create_image(0, 0, anchor=tk.NW, image=imgtk)
            self.canvas.image = imgtk  # Mantém referência
            
        except Exception as e:
            self.log(f"Erro ao exibir imagem: {e}")
    
    def on_mouse_move(self, event):
        """Envia evento de movimento do mouse com throttling."""
        if self.connected:
            current_time = time.time()
            # Limita envio de eventos de mouse a cada 50ms
            if current_time - self.last_mouse_move >= self.mouse_throttle:
                self.send_data(f"mouse_move {event.x} {event.y}")
                self.last_mouse_move = current_time
    
    def send_mouse_click(self, button):
        """Envia clique do mouse."""
        if self.connected:
            self.send_data(f"mouse_click {button}")
    
    def on_key_press(self, event):
        """Envia evento de teclado."""
        if self.connected:
            key = event.char
            if key:
                self.send_data(f"keyboard {key}")
    
    def get_system_info(self):
        """Solicita informações do sistema."""
        if self.connected:
            self.send_data("system_info")
    
    def change_quality(self, event):
        """Altera a qualidade da transmissão."""
        quality = self.quality_var.get()
        if self.connected:
            # Envia comando de qualidade para o servidor
            self.send_data(f"quality {quality}")
            self.log(f"Qualidade alterada para: {quality}")
    
    def open_command_dialog(self):
        """Abre diálogo para executar comando."""
        if not self.connected:
            return
        
        # Cria janela de diálogo
        dialog = tk.Toplevel(self.root)
        dialog.title("Executar Comando")
        dialog.geometry("400x150")
        
        ttk.Label(dialog, text="Digite o comando:").pack(pady=10)
        
        command_entry = ttk.Entry(dialog, width=50)
        command_entry.pack(pady=10)
        
        def execute_command():
            cmd = command_entry.get()
            if cmd:
                self.send_data(f"exec {cmd}")
                dialog.destroy()
        
        ttk.Button(dialog, text="Executar", command=execute_command).pack(pady=10)
    
    def on_closing(self):
        """Tratamento de fechamento da janela."""
        if self.connected:
            self.disconnect()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = OptimizedRemoteClient(root)
    
    # Configura evento para após o carregamento completo da janela
    root.update()
    root.deiconify()
    
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()