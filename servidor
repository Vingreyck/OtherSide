import socket
import threading
import pickle
import struct
import cv2
import numpy as np
import pyautogui
import platform
import subprocess
from PIL import ImageGrab
from queue import Queue

class EnhancedRemoteServer:
    def __init__(self, host='0.0.0.0', port=9999):
        self.host = host
        self.port = port
        
        # Socket configuration
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # Client management
        self.clients = []
        self.command_queue = Queue()
        
        # Control flags
        self.running = True
        self.screenshot_interval = 0.1  # 10 fps
    
    def start_server(self):
        """Inicia o servidor e aceita conexões."""
        try:
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(5)
            print(f"Servidor iniciado em {self.host}:{self.port}")
            
            # Thread para processamento de comandos
            command_thread = threading.Thread(target=self.process_commands)
            command_thread.daemon = True
            command_thread.start()
            
            while self.running:
                client_socket, address = self.server_socket.accept()
                print(f"Conexão de {address}")
                
                client_thread = threading.Thread(target=self.handle_client, args=(client_socket,))
                client_thread.daemon = True
                client_thread.start()
                
                self.clients.append(client_socket)
        
        except Exception as e:
            print(f"Erro no servidor: {e}")
        finally:
            self.stop_server()
    
    def handle_client(self, client_socket):
        """Gerencia comunicação com cliente individual."""
        try:
            # Thread para streaming de tela
            screen_thread = threading.Thread(target=self.continuous_screen_capture, args=(client_socket,))
            screen_thread.daemon = True
            screen_thread.start()
            
            while self.running:
                # Recebe comandos do cliente
                command = self.receive_data(client_socket)
                
                if not command:
                    break
                
                # Processamento de diferentes tipos de comandos
                if command.startswith('mouse_move'):
                    _, x, y = command.split()
                    self.command_queue.put(('mouse_move', (int(x), int(y))))
                
                elif command.startswith('mouse_click'):
                    _, button = command.split()
                    self.command_queue.put(('mouse_click', button))
                
                elif command.startswith('keyboard'):
                    _, key = command.split()
                    self.command_queue.put(('keyboard', key))
                
                elif command == 'system_info':
                    info = self.get_system_info()
                    self.send_data(client_socket, info)
                
                elif command.startswith('exec'):
                    _, cmd = command.split(' ', 1)
                    result = self.execute_command(cmd)
                    self.send_data(client_socket, result)
        
        except Exception as e:
            print(f"Erro no cliente: {e}")
        finally:
            client_socket.close()
            self.clients.remove(client_socket)
    
    def continuous_screen_capture(self, client_socket):
        """Captura contínua de tela."""
        try:
            while self.running:
                # Captura tela
                screen = ImageGrab.grab()
                screen_np = np.array(screen)
                
                # Converte e comprime
                screen_np = cv2.cvtColor(screen_np, cv2.COLOR_RGB2BGR)
                scaled = cv2.resize(screen_np, (0,0), fx=0.5, fy=0.5)
                
                # Codifica a imagem
                _, buffer = cv2.imencode('.jpg', scaled, [cv2.IMWRITE_JPEG_QUALITY, 80])
                
                # Envia dados
                self.send_data(client_socket, buffer)
                
                # Controla taxa de quadros
                import time
                time.sleep(self.screenshot_interval)
        
        except Exception as e:
            print(f"Erro na captura de tela: {e}")
    
    def process_commands(self):
        """Processa comandos de controle."""
        while self.running:
            try:
                command_type, data = self.command_queue.get(timeout=1)
                
                if command_type == 'mouse_move':
                    x, y = data
                    pyautogui.moveTo(x, y)
                
                elif command_type == 'mouse_click':
                    pyautogui.click(button=data)
                
                elif command_type == 'keyboard':
                    pyautogui.write(data)
                
                self.command_queue.task_done()
            
            except Exception as e:
                pass  # Fila vazia, continua
    
    def send_data(self, connection, data):
        """Envia dados serializados."""
        serialized = pickle.dumps(data)
        connection.send(struct.pack("Q", len(serialized)) + serialized)
    
    def receive_data(self, connection):
        """Recebe dados serializados."""
        try:
            data_size = struct.unpack("Q", connection.recv(8))[0]
            data = b""
            while len(data) < data_size:
                packet = connection.recv(data_size - len(data))
                data += packet
            return pickle.loads(data)
        except:
            return None
    
    def get_system_info(self):
        """Obtém informações do sistema."""
        return {
            'os': platform.system(),
            'release': platform.release(),
            'processor': platform.processor(),
            'machine': platform.machine()
        }
    
    def execute_command(self, command):
        """Executa comando no sistema."""
        try:
            return subprocess.check_output(command, shell=True).decode()
        except Exception as e:
            return str(e)
    
    def stop_server(self):
        """Encerra o servidor."""
        self.running = False
        for client in self.clients:
            client.close()
        self.server_socket.close()

if __name__ == "__main__":
    server = EnhancedRemoteServer()
    server.start_server()